package{        import com.adobe.crypto.HMAC;    import com.adobe.crypto.SHA1;    import com.adobe.serialization.json.JSON;        import flash.events.Event;    import flash.events.EventDispatcher;    import flash.events.HTTPStatusEvent;    import flash.events.IOErrorEvent;    import flash.events.NetStatusEvent;    import flash.events.ProgressEvent;    import flash.events.SecurityErrorEvent;    import flash.events.TimerEvent;    import flash.net.URLLoader;    import flash.net.URLLoaderDataFormat;    import flash.net.URLRequest;    import flash.net.URLRequestHeader;    import flash.net.URLRequestMethod;    import flash.net.URLVariables;    import flash.system.Security;    import flash.utils.Timer;        public class PBSFeedClient extends EventDispatcher    {                public static var IOERROR:String = "IOERROR";        private var dataChanged:Boolean = false;                private var loader:URLLoader;        private var request:URLRequest = null;        private var url:String = null;        private var currentVideoFeedData:Object = null;        private var currentImageFeedData:Object = null;               // is a Singleton        private static var _instance:PBSFeedClient;        /// for pbs and litl tracking purposes - not mandatory        private static const TRACKING_CODE:String = "your_tracking_code";        /// maximum number of items we want returned from the feed - not mandatory        private static const MAX_FEED_ITEMS:Number = 150;        private static const API_ID:String = "your_api_id";        private static const SHOW_ID = "NOVA";        private static const API_PASSWORD:String = "your_api_password";                /**         * Get access to the unique PBS instance (singleton)         *         * @return the unique PBSFeedClient instance         */                public static function getInstance():PBSFeedClient {            if (_instance == null)                _instance = new PBSFeedClient();                        return _instance;        }                /**         * Constructor, never to be used outside         */        public function PBSFeedClient() {            // Allow the player to communicate with our sandbox.            Security.allowDomain("http://api.pbs.org/cove/");                    }                /**         * Construct, sign and fetch the feed         *         */        public function getVideoFeed():void {                                    // how you retrieve this show id is dependent upon your design. for now it's hard coded within this class             // var showId:String = model.showFeedId;            // get the amount of time since Jan 1, 1970 00:00:00            var currentDate:Date = new Date();            var timestamp:Object = Math.round((currentDate.time / 1000));            // random number - can be anything            var randomNonce:Number = Math.round(Math.random() * 1000);            // the initial query            var videoQuery:String = "http://api.pbs.org/cove/v1/videos/?consumer_key=" + API_ID + "&fields=associated_images%2Cmediafiles&filter_nola_root=" + SHOW_ID + "&filter_type=Episode&format=json&limit_start=0&limit_stop=" + MAX_FEED_ITEMS + "&nonce=" + randomNonce + "&order_by=-airdate&timestamp=" + timestamp;            // the query to authenticate            var queryToSign:String = "GET" + videoQuery + timestamp + API_ID + randomNonce;            // and now hash it to create your signature - using the SHA1 algorithm            var signature:String = HMAC.hash(API_PASSWORD, queryToSign, SHA1);            // now you have your final feed url to try and load            var videoFeedUrl:String = videoQuery + "&signature=" + signature;            // fetch the url            fetchFeed(videoFeedUrl, onFeedLoadComplete);                    }                /**         * load the url         *         * @param url the url to load         * @param onComplete the function to run after a successful load has completed         */        private function fetchFeed(url:String, onComplete:Function):void {            try {                var httpHeader:URLRequestHeader = new URLRequestHeader("Cache-Control", "no-store");                request = new URLRequest(url);                                request.requestHeaders.push(httpHeader);                request.method = URLRequestMethod.GET;                                if (request != null) {                    loader = new URLLoader();                    loader.dataFormat = URLLoaderDataFormat.TEXT;                    loader.addEventListener(Event.COMPLETE, onComplete);                    loader.addEventListener(IOErrorEvent.IO_ERROR, onError);                    loader.load(request);                }                            }            catch (e:Error) {                trace("fetchFeed error: " + e);                onError(null);            }                    }                /**         *          */        protected function onFeedLoadComplete(evt:Event):void {                        loader.removeEventListener(Event.COMPLETE, onFeedLoadComplete);            loader.removeEventListener(IOErrorEvent.IO_ERROR, onError);            var feedData:Object = JSON.decode(evt.target.data as String).results;            trace("raw feed data : " + evt.target.data as String);        }                /**         * onError         * Called when there was a communication error with the Feed service         */        public function onError(event:IOErrorEvent):void {            trace("Load failed: IO error: " + event.text);        }                /**         * handleException         * Handles an exception loading or processing the Feed data         *         */        public function handleException(e:Error):void {            // handle data services exceptions: typically they will be xml            // parsing errors if someone has tweaked the xml            errMsg = "handleException " + e.name + "," + e.message;            trace(errMsg);            dispatchEvent(new Event(IOERROR));        }    }    }